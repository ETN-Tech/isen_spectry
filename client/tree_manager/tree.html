<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">

    <title>Tree Example</title>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jquery-modal/0.9.1/jquery.modal.min.css" />

    <style>
	
	.node {
		cursor: pointer;
	}

	.node circle {
	  fill: #fff;
	  stroke: steelblue;
	  stroke-width: 3px;
	}

	.node text {
	  font: 12px sans-serif;
	}

	.link {
	  fill: none;
	  stroke: #ccc;
	  stroke-width: 2px;
	}
	
    </style>

  </head>

  <body>
	  <div id="nodeSettings" class="modal">
			<p>
			Nom : 
			<input id="nodeName" type="text">
			</p>
	  </div>


<!-- load the d3.js library -->	
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.17/d3.min.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-modal/0.9.1/jquery.modal.min.js"></script>

<script>

// ************** Generate the tree diagram	 *****************
var margin = {top: 20, right: 120, bottom: 20, left: 120},
	width = 960 - margin.right - margin.left,
	height = 500 - margin.top - margin.bottom;
	
var i = 0,
	duration = 500,
	root;

var tree = d3.layout.tree()
	.size([height, width]);

var diagonal = d3.svg.diagonal()
	.projection(function(d) { return [d.y, d.x]; });

var svg = d3.select("body").append("svg")
	.attr("width", width + margin.right + margin.left)
	.attr("height", height + margin.top + margin.bottom)
  .append("g")
	.attr("transform", "translate(" + margin.left + "," + margin.top + ")");


// treeData = [
// 	{
// 		"name" : "Root",
// 		"parent" : "null",
// 		"path":"root",
// 		"children" : [
// 			{
// 			"name":"Screens",
// 			"parent":"Root",
// 			"path":"root_screens",
// 			"children": [
// 				{
// 					"name":"+",
// 					"parent":"Screens",
// 					"type" : "add",
// 				}
// 			]
// 			}
// 		]
// 	}
// ]
// root = treeData[0];
// root.x0 = height/2;
// root.y0 = 0;
  
// update(root);

// d3.select(self.frameElement).style("height", "500px");








// root = new MainNode()
// root = new MainNode()
// test = root.addChild("test");
// test2 = root.addChild("test2");
// test3 = root.addChild("test3");
// test2.addChild("bébé")


// dat = root.toJson()
// update(dat)






function saveNodeName(node){
	node.name = $("#nodeName").val();
	d3.select("#" + node.path).select("text").text(node.name);
	$("#nodeSettings").modal("hide");
}



class Node {
	constructor(name, parent= null, root= null){
		this.name = name;
		this.children = [];
		this.parent = parent;
		this.path = parent == null ? "root" : parent.path + "_" + name;
		this.root = root;
		this.depth = parent == null ? 0 : this.parent.depth + 1 ;
		this.element = null;

	}

	addChild(name){
		let child = new Node(name, this, this.root);
		if (!this.children) {
			this.children = [];
		}
		this.children.push(child);
		this.update(child.parent);
		return child;
	}

	addAddingChild(){
		let child = new AddingNode(this);
		if (!this.children) {
			this.children = [];
		}
		this.children.push(child);
		this.update(this);
		return child;
	}

	click(){
	}

	editNode(node){
		$("#nodeName").val("");
		$("#nodeName").attr("placeholder", node.name);
		$("#nodeName").on("keypress", function(e){
			if(e.keyCode == 13){
				this.blur();
				saveNodeName(node);
				$("#nodeName").off("keypress");
			}
		});
		$("#nodeSettings").attr("nodeId", node.path);
		$("#nodeSettings").modal("show");
	}

	update(source) {
		// Compute the new tree layout.
		var nodes = tree.nodes(this.root).reverse(),
			links = tree.links(nodes);
		// Normalize for fixed-depth.
		nodes.forEach(function(d) {d.y = d.depth * 180; });
		// Update the nodes…
		var node = svg.selectAll("g.node")
			.data(nodes, function(d) { return d.id || (d.id = ++i); });

		// Enter any new nodes at the parent's previous position.
		// console.log(source)
		var nodeEnter = node.enter().append("g")
		.attr("class", function(d){return d.type ? "node " + d.type : "node"})
		.attr("id", function(d){return d.path})
		.attr("transform", function(d) { return "translate(" + source.y0 + "," + source.x0 + ")"; })
		.on("click", function(d){d.click();});
		
		nodeEnter.append("circle")
		.attr("r", 30)
		.style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });


		nodeEnter.append("text")
		.text(function(d){return d.name;})
		.attr("text-anchor", "middle");


		// Transition nodes to their new position.
		var nodeUpdate = node.transition()
			.duration(duration)
			.attr("transform", function(d) {return "translate(" + d.y + "," + d.x + ")"; });

		nodeUpdate.select("circle")
			.attr("r", 30)
			.style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });

		nodeUpdate.select("text")
			.style("fill-opacity", 1);

		// Transition exiting nodes to the parent's new position.
		var nodeExit = node.exit().transition()
			.duration(duration)
			.attr("transform", function(d) { return "translate(" + source.y + "," + source.x + ")"; })
			.remove();

		nodeExit.select("circle")
			.attr("r", 1e-6);

		nodeExit.select("text")
			.style("fill-opacity", 1e-6);
			

		// Update the links…
		var link = svg.selectAll("path.link")
			.data(links, function(d) { return d.target.id; });

		// Enter any new links at the parent's previous position.
		link.enter().insert("path", "g")
			.attr("class", "link")
			.attr("d", function(d) {
				var o = {x: source.x0, y: source.y0};
				return diagonal({source: o, target: o});
			});

		// Transition links to their new position.
		link.transition()
			.duration(duration)
			.attr("d", diagonal);

		// Transition exiting nodes to the parent's new position.
		link.exit().transition()
			.duration(duration)
			.attr("d", function(d) {
				var o = {x: source.x, y: source.y};
				return diagonal({source: o, target: o});
			})
			.remove();

		// Stash the old positions for transition.
		nodes.forEach(function(d) {
			d.x0 = d.x;
			d.y0 = d.y;
		});
		}

	toJson(){
		let data = {"name" : this.name,
		"parent" : this.parent,
		"children": this.children
		}
		return data;
	}

}

class MainNode extends Node {
	constructor(){
		super("Root");
		this.x0 = 250;
		this.y0 = 0;
		this.root = this;
	}
}

class AddingNode extends Node {
	constructor(parent){
		super("+", parent, parent.root);
	}
	
	click() {
		let screenNode = new ScreenNode("Screen " + (this.parent.children.length), this.parent)
		screenNode.path = this.parent.path + "_" + String(this.parent.children.length - 1);
		this.parent.children.splice(-1, 0, screenNode);
		this.update(this.parent)
		let node = d3.select("#" + screenNode.path);
		node.select("text")
		.text(this.parent.children.length - 1)
		.attr("text-anchor", "middle");
		node.on("click", function(node){
			this.editNode(node);
		}.bind(this));
	}
}

class ScreenNode extends Node {
	constructor(name, parent){
		super(name, parent);
	}
}


test = new MainNode();
screens = test.addChild("Screens")
// screens.addAddingChild();
screens.addAddingChild()
</script>
	
  </body>
</html>